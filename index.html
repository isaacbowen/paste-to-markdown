<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Clipboard HTML to Markdown Converter</title>
  <!-- Google Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500&display=swap" rel="stylesheet">
  <style>
    body {
      font-family: 'Roboto', sans-serif;
      margin: 0;
      padding: 0;
      background-color: #f5f5f5;
    }
    .container {
      max-width: 800px;
      margin: 50px auto;
      background-color: #ffffff;
      border-radius: 8px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
      padding: 30px;
    }
    h1 {
      text-align: center;
      color: #333333;
      margin-bottom: 30px;
    }
    #convert-button {
      display: block;
      width: 100%;
      padding: 15px;
      font-size: 16px;
      background-color: #6200ea;
      color: #ffffff;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      margin-bottom: 20px;
    }
    #convert-button:hover {
      background-color: #3700b3;
    }
    #markdown-output {
      width: 100%;
      height: 400px;
      padding: 15px;
      font-size: 14px;
      border: 1px solid #cccccc;
      border-radius: 4px;
      resize: vertical;
      box-sizing: border-box
    }
  </style>
</head>
<body>

<div class="container">
  <h1>Clipboard HTML to Markdown Converter</h1>

  <textarea id="markdown-output" placeholder="Paste HTML here!"></textarea>
</div>

<!-- Include Turndown via CDN -->
<script src="https://cdn.jsdelivr.net/npm/turndown/dist/turndown.min.js"></script>
<script>
  // Function to preprocess HTML content
  function preprocessHTML(htmlContent) {
    // Create a DOM parser
    const parser = new DOMParser();
    const doc = parser.parseFromString(htmlContent, 'text/html');

    // Find all paragraphs with style="white-space: pre-wrap;"
    const preWrapParagraphs = doc.querySelectorAll('p[style*="white-space: pre-wrap"]');

    preWrapParagraphs.forEach(p => {
      // Replace line breaks (\n) in text nodes with <br> elements
      const childNodes = Array.from(p.childNodes);
      childNodes.forEach(node => {
        if (node.nodeType === Node.TEXT_NODE) {
          const lines = node.textContent.split(/\r\n|\n|\r/);
          const fragment = doc.createDocumentFragment();
          lines.forEach((line, index) => {
            fragment.appendChild(doc.createTextNode(line));
            if (index < lines.length - 1) {
              fragment.appendChild(doc.createElement('br'));
            }
          });
          p.replaceChild(fragment, node);
        }
      });
    });

    // Serialize the modified document back to HTML
    return doc.body.innerHTML;
  }

  // Function to convert HTML content to Markdown
  function convertContent(htmlContent) {
    // Preprocess HTML content
    htmlContent = preprocessHTML(htmlContent);

    // Initialize TurndownService with options
    const turndownService = new TurndownService({
      headingStyle: 'atx',
      codeBlockStyle: 'fenced',
      emDelimiter: '*',
      strongDelimiter: '**',
      bulletListMarker: '-',
    });

    // Custom rule to handle <br> tags
    turndownService.addRule('lineBreak', {
      filter: 'br',
      replacement: function (content, node, options) {
        return '  \n'; // Two spaces and a newline for Markdown line break
      }
    });

    // Custom rule to handle headings
    turndownService.addRule('customHeadings', {
      filter: ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'],
      replacement: function (content, node) {
        const hLevel = Number(node.nodeName.charAt(1));
        const hPrefix = Array(hLevel + 1).join('#') + ' ';
        const textContent = node.textContent.trim();
        return '\n\n' + hPrefix + textContent + '\n\n';
      }
    });

    // Add rules to handle inline styles like italic, bold, and underline
    turndownService.addRule('italicText', {
      filter: function (node) {
        return (
          (node.nodeName === 'SPAN' && node.style.fontStyle === 'italic') ||
          node.nodeName === 'I' ||
          node.nodeName === 'EM'
        );
      },
      replacement: function (content) {
        return '*' + content + '*';
      }
    });

    turndownService.addRule('boldText', {
      filter: function (node) {
        return (
          (node.nodeName === 'SPAN' && (node.style.fontWeight === 'bold' || parseInt(node.style.fontWeight) >= 700)) ||
          node.nodeName === 'B' ||
          node.nodeName === 'STRONG'
        );
      },
      replacement: function (content) {
        return '**' + content + '**';
      }
    });

    turndownService.addRule('underlineText', {
      filter: function (node) {
        return (
          (node.nodeName === 'SPAN' && node.style.textDecoration.includes('underline')) ||
          node.nodeName === 'U'
        );
      },
      replacement: function (content) {
        return '<u>' + content + '</u>';
      }
    });

    // Add a rule to ignore empty links
    turndownService.addRule('ignoreEmptyLinks', {
      filter: function (node) {
        return (
          node.nodeName === 'A' &&
          (!node.textContent || node.textContent.trim() === '')
        );
      },
      replacement: function () {
        return ''; // Remove the link entirely
      }
    });

    // Convert HTML to Markdown
    let markdown = turndownService.turndown(htmlContent);

    // hr
    markdown = markdown.replace(/^\\?-{2,}/mg, '* * *');

    // Replace '--' with '—' (em dash)
    markdown = markdown.replace(/--/g, '—');

    return markdown.trim();
  }

  // Event listener for paste events anywhere on the page
  document.addEventListener('paste', (event) => {
    event.preventDefault();
    try {
      const clipboardData = event.clipboardData || window.clipboardData;
      let htmlContent = '';

      if (clipboardData.types.includes('text/html')) {
        htmlContent = clipboardData.getData('text/html');
      } else if (clipboardData.types.includes('text/plain')) {
        htmlContent = clipboardData.getData('text/plain');
      }

      if (!htmlContent) {
        alert('No content found in clipboard!');
        return;
      }

      // Convert content and display
      const markdown = convertContent(htmlContent);
      document.getElementById('markdown-output').value = markdown;

    } catch (err) {
      console.error('Failed to process pasted content: ', err);
      alert('Failed to process pasted content: ' + err);
    }
  });
</script>

</body>
</html>
